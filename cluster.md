聚类算法

主要的应用场景：可以使用聚类算法，按照相似性，以及结构性的概念，来对数据进行组织

重要的应用：对数据进行无监督的预分类，面对一个复杂的分类问题，可以使用聚类算法，首先对手上的数据进行预分类，对聚类算法得出的每一类，应用一个不同的分类模型，最后把这些模型的结果组合起来得到最后一个组合的分类模型



聚类算法分为

​	分割型聚类：把给定的数据点分割到不同的类中

​	层次聚类：把数据分层，得到一个树状的结构，这个结构动态的显示了类别与类别之间的嵌套关系



聚类算法的作用：进行数据压缩

## Hard-Kmeans

Hard kmeans 分为 kmeans 和 k-medoids

kmeans的缺点：

1. 聚类中心不一定属于数据集
2. 使用了 L2 距离，就是平方了，很容易被噪声影响



对于kmeans算法的优化，**k-medoids**算法，改进之处

1. 限制聚类中心一定要来自数据集
2. 使用 L1 距离
3. 不过k-medoids算法因为中心一定要来自于数据集，所以更新质心的算法复杂度是O(n^2)

kmeans的扩展：soft-kmeans

## Soft-Kmeans

Hard-Kmeans 本质上就是求**取那几个中心点**可以使得这个簇中的点到属于它的中心点之和最小，

损失函数：

![1566740805760](C:\Users\Liang\AppData\Roaming\Typora\typora-user-images\1566740805760.png)





**换一种视角来看这个损失函数 👇**

其实损失函数可以更换一种方式表达

![1566741479781](C:\Users\Liang\AppData\Roaming\Typora\typora-user-images\1566741479781.png)

就是给每一个样本点到质心的距离一个加权，这个加权表示这个样本点属于这个质心对应的簇的**置信度**

在 i 个样本点中，对于任意一个样本点，都只存在一个对应的权重rij=1，使得该样本点到 j 个质心中的某一个距离最小



那么此时就可以得到 **加权质心公式**，在原本的质心公式上变成一个加权版本的质心公式

![1566784706059](C:\Users\Liang\AppData\Roaming\Typora\typora-user-images\1566784706059.png)

这个求加权质心的意思是：只会给定一个样本点，其加权的权重为1，使得最小化损失函数



假设现在，对于不同的样本点作为质心的置信度，即这个加权值rij，是一个 [0, 1]  之间的值，所有rij之和等于1，那么这个rij就可以理解为一个概率，即不同的样本点作为聚类中心的概率

![1566785394236](C:\Users\Liang\AppData\Roaming\Typora\typora-user-images\1566785394236.png)

对于 Hard-Kmeans，rij 取 1 是在样本点到质心的距离最小的时候才取的 1，其他的全取为 0，而对于Soft-Kmeans，是根据每个样本点 xi 到 μj 的距离远近，给予不同的概率 rij ，那么当前的加权质心公式就是

![1566786522830](C:\Users\Liang\AppData\Roaming\Typora\typora-user-images\1566786522830.png)

分子的意思是，xi 距离 μj 越近，分子越大，分母其实是进行归一化，所以，xi 距离 μj 越近，rij就越大



此时取得质心更新公式还是![1566787267670](C:\Users\Liang\AppData\Roaming\Typora\typora-user-images\1566787267670.png)